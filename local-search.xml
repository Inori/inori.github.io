<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>球谐函数的计算与证明</title>
    <link href="/2023/08/22/spherical-harmonics-calculation/"/>
    <url>/2023/08/22/spherical-harmonics-calculation/</url>
    
    <content type="html"><![CDATA[<h3 id="曲线空间坐标"><a href="#曲线空间坐标" class="headerlink" title="曲线空间坐标"></a>曲线空间坐标</h3><img src="/2023/08/22/spherical-harmonics-calculation/q1q2q3.jpg" class="" title="q1q2q3">  <img src="/2023/08/22/spherical-harmonics-calculation/1.jpg" class="" title="p1">  <img src="/2023/08/22/spherical-harmonics-calculation/2.jpg" class="" title="p2">  <img src="/2023/08/22/spherical-harmonics-calculation/3.jpg" class="" title="p3">  <img src="/2023/08/22/spherical-harmonics-calculation/4.jpg" class="" title="p4">  <h3 id="球坐标下拉普拉斯方程"><a href="#球坐标下拉普拉斯方程" class="headerlink" title="球坐标下拉普拉斯方程"></a>球坐标下拉普拉斯方程</h3><p>曲线坐标下的坐标值，不一定表示长度，也可以是角度等，比如下面要计算的$\theta ,\varphi $就是角度量，为了转换成直角下的长度，就需要一个比率系数，这就是拉梅系数。  </p><p>对于$r$分量，在曲线坐标中移动一个单位长度，直角坐标中也是移动一个单位长度，所以$H_r&#x3D;1$   </p><p>而$\theta$分量移动一个单位，对应直角坐标中沿球面经向转过$\theta$角度，那么直角坐标中长度的变化量就是$r$，所以$H_{\theta}&#x3D;r$</p><p>最后的计算结果是符合直觉的。</p><img src="/2023/08/22/spherical-harmonics-calculation/sphere.jpg" class="" title="sphere">  <img src="/2023/08/22/spherical-harmonics-calculation/5.jpg" class="" title="p5">  <img src="/2023/08/22/spherical-harmonics-calculation/6.jpg" class="" title="p6">  <h3 id="分离变量法"><a href="#分离变量法" class="headerlink" title="分离变量法"></a>分离变量法</h3><img src="/2023/08/22/spherical-harmonics-calculation/7.jpg" class="" title="p7">  <img src="/2023/08/22/spherical-harmonics-calculation/8.jpg" class="" title="p8">  <h3 id="解-varphi-方程"><a href="#解-varphi-方程" class="headerlink" title="解 $\varphi $ 方程"></a>解 $\varphi $ 方程</h3><img src="/2023/08/22/spherical-harmonics-calculation/9.jpg" class="" title="p9">  <img src="/2023/08/22/spherical-harmonics-calculation/10.jpg" class="" title="p10">  <h3 id="解-theta-方程"><a href="#解-theta-方程" class="headerlink" title="解 $\theta $ 方程"></a>解 $\theta $ 方程</h3><img src="/2023/08/22/spherical-harmonics-calculation/11.jpg" class="" title="p11">  <h4 id="解勒让德方程"><a href="#解勒让德方程" class="headerlink" title="解勒让德方程"></a>解勒让德方程</h4><img src="/2023/08/22/spherical-harmonics-calculation/12.jpg" class="" title="p12">  <img src="/2023/08/22/spherical-harmonics-calculation/13.jpg" class="" title="p13">  <img src="/2023/08/22/spherical-harmonics-calculation/14.jpg" class="" title="p14">  <img src="/2023/08/22/spherical-harmonics-calculation/15.jpg" class="" title="p15">  <h4 id="解连带勒让德方程"><a href="#解连带勒让德方程" class="headerlink" title="解连带勒让德方程"></a>解连带勒让德方程</h4><img src="/2023/08/22/spherical-harmonics-calculation/16.jpg" class="" title="p16">  <img src="/2023/08/22/spherical-harmonics-calculation/17.jpg" class="" title="p17">  <h3 id="球函数"><a href="#球函数" class="headerlink" title="球函数"></a>球函数</h3><img src="/2023/08/22/spherical-harmonics-calculation/18.jpg" class="" title="p18">  <p>还得祭出这张图，图中从上到下依次为$l&#x3D;0, 1, 2, 3$阶球函数，蓝色为正值，黄色为负值，颜色越亮绝对值越大。 </p><p>另外之所以有像电子云(并不是)一样的形状，只是因为除了颜色以为，图中还使用到原点的距离来表示了$Y_{l}^{m}$函数的值。<br>可以这样理解，首先在单位球面上取一点$P(x, y, z)$,把点$P$坐标代入球函数$Y_{l}^{m}$，这样会计算出一个值$d$，在原点至$P$点的连线$OP$上截取长度为$d$的线段$OD$，这样取遍单位球上的点$P$，就可以得到所有对应的点$D$, $D$的合集就是图上的奇怪形状了</p><img src="/2023/08/22/spherical-harmonics-calculation/sh.jpg" class="" title="SH">  <h3 id="旋转不变性"><a href="#旋转不变性" class="headerlink" title="旋转不变性"></a>旋转不变性</h3><p>此即为球函数的加法公式，可以根据球心至球面任意两点连线形成的两向量的内积，不随球坐标旋转而改变，这一性质来证明<br>TODO</p><h3 id="计算举例"><a href="#计算举例" class="headerlink" title="计算举例"></a>计算举例</h3><img src="/2023/08/22/spherical-harmonics-calculation/19.jpg" class="" title="p19">  <p>可以看到和<a href="https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Source/Runtime/Core/Public/Math/SHMath.h#L472">UE5里SH函数</a>计算结果一致:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-keyword">inline</span> TSHVector&lt;<span class="hljs-number">3</span>&gt; TSHVector&lt;<span class="hljs-number">3</span>&gt;::<span class="hljs-built_in">SHBasisFunction</span>(<span class="hljs-type">const</span> FVector&amp; Vector) <br>&#123;<br>TSHVector&lt;<span class="hljs-number">3</span>&gt; Result;<br>Result.V[<span class="hljs-number">0</span>] = <span class="hljs-number">0.282095f</span>; <br>Result.V[<span class="hljs-number">1</span>] = <span class="hljs-number">-0.488603f</span> * (<span class="hljs-type">float</span>)Vector.Y;<span class="hljs-comment">// LWC_<span class="hljs-doctag">TODO:</span> Precision loss</span><br>Result.V[<span class="hljs-number">2</span>] = <span class="hljs-number">0.488603f</span> * (<span class="hljs-type">float</span>)Vector.Z;<br>Result.V[<span class="hljs-number">3</span>] = <span class="hljs-number">-0.488603f</span> * (<span class="hljs-type">float</span>)Vector.X;<br><br>FVector VectorSquared = Vector * Vector;<br>Result.V[<span class="hljs-number">4</span>] = <span class="hljs-number">1.092548f</span> * <span class="hljs-built_in">float</span>(Vector.X * Vector.Y);<br>Result.V[<span class="hljs-number">5</span>] = <span class="hljs-number">-1.092548f</span> * <span class="hljs-built_in">float</span>(Vector.Y * Vector.Z);<br>Result.V[<span class="hljs-number">6</span>] = <span class="hljs-number">0.315392f</span> * <span class="hljs-built_in">float</span>(<span class="hljs-number">3.0f</span> * VectorSquared.Z - <span class="hljs-number">1.0f</span>);<br>Result.V[<span class="hljs-number">7</span>] = <span class="hljs-number">-1.092548f</span> * <span class="hljs-built_in">float</span>(Vector.X * Vector.Z);<br>Result.V[<span class="hljs-number">8</span>] = <span class="hljs-number">0.546274f</span> * <span class="hljs-built_in">float</span>(VectorSquared.X - VectorSquared.Y);<br><span class="hljs-keyword">return</span> Result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mathematics for Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Games202</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Path Tracing 中 Russian Roulette 的期望</title>
    <link href="/2023/08/03/expectation-of-russian-roulette-in-path-tracing/"/>
    <url>/2023/08/03/expectation-of-russian-roulette-in-path-tracing/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Path Tracing 的递归算法中要解决一个问题，就是光线不能无限反射，需要有一个停止的条件，一种方法就是使用俄罗斯轮盘赌，Russian Roulette (RR)，只有通过RR时才继续算反射，否则停止递归，这样即能避免无限递归，又能保证能量守恒。</p><h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><p>和群友Irimsky &#96;讨论发现之前自己的计算是不对的，之前我认为期望就简单这么算：<br>$$<br>E\left( p \right) &#x3D;1p+2p^2+3p^3+\cdots +np^p<br>$$<br>就简单反射次数乘以$p$的$n$次方，最后算出来：<br>$$<br>E\left( p \right) &#x3D;\frac{p}{\left( 1-p \right) ^2}<br>$$<br>但是这是不对的，这种情况下$p&#x3D;0.5$，期望是2次，$p&#x3D;0.8$，是20次。<br>为此我还写了段代码来数值计算：</p><img src="/2023/08/03/expectation-of-russian-roulette-in-path-tracing/test.jpg" class="" title="p2">  <br/><br/>结果显然和上面的公式不符，那么错到哪了呢？  错的地方就在于，之前计算的时候，没有考虑失败的情况，比如说认为反射2次的情况是$2p^2$，但是这种情况下，**第3次会不会反射是不确定的**，正确的算法应该是再乘以失败的概率来终结反射，也就是$3p^2(1-p)$<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>设RR通过概率概率是$p$，$p&#x3D;0$不反射，$p&#x3D;1$无限次反射，$0&lt;p&lt;1$时期望为：<br>$$<br>E\left( p \right) &#x3D;\frac{p}{1-p}<br>$$</p><p>也就是说，如果$p&#x3D;0.5$，那么大体上会反射2次，$p&#x3D;0.8$，大体上会反射4次<br><br/><br>其实这里的概率就是几何分布，几何分布就是求前n-1次失败的前提下，第n次成功的概率，如果熟悉概率公式，几何分布的期望就是：<br>$$<br>E\left( p \right) &#x3D;\frac{1}{p}<br>$$<br>对于我们的情况，要把成功和失败反过来，因为我们要算的是前n-1次成功，第n次失败情况，也就是说，赌局总次数的期望为：<br>$$<br>E\left( p \right) &#x3D;\frac{1}{1-p}<br>$$<br>再减去最后一次的失败，那么反射次数就是：<br>$$<br>S\left( p \right) &#x3D;E\left( p \right) -1<br>\<br>&#x3D;\frac{1}{1-p}-1<br>\<br>&#x3D;\frac{p}{1-p}<br>$$</p><h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><img src="/2023/08/03/expectation-of-russian-roulette-in-path-tracing/p1.jpg" class="" title="p1">  <h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p>Games 101<br><a href="https://www.bilibili.com/video/BV1X7411F744?t=3248.4&p=16">https://www.bilibili.com/video/BV1X7411F744?t=3248.4&amp;p=16</a></p>]]></content>
    
    
    <categories>
      
      <category>Mathematics for Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Games101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>齐次坐标与变换的几何解释</title>
    <link href="/2023/07/25/geometry_understanding_of_homogeneous_coordinates/"/>
    <url>/2023/07/25/geometry_understanding_of_homogeneous_coordinates/</url>
    
    <content type="html"><![CDATA[<h3 id="代数理解"><a href="#代数理解" class="headerlink" title="代数理解"></a>代数理解</h3><p>对于为何引入齐次坐标，一般的分析文章都会从代数的角度出发，给出如下公式：<br>$$<br>\left[ \begin{array}{c}<br>    x\\<br>    y\\<br>    z\\<br>    1\\<br>\end{array} \right] \left[ \begin{array}{ccc:c}<br>    a_{11}&amp;a_{13}&amp;a_{13}&amp;t_x\\<br>    a_{21}&amp;a_{22}&amp;a_{23}&amp;t_y\\<br>    a_{31}&amp;a_{32}&amp;a_{33}&amp;t_z\\<br>    \hdashline<br>    0&amp;0&amp;0&amp;1\\<br>\end{array} \right] &#x3D;\left[ \begin{matrix}<br>    M&amp;T\\<br>    0&amp;1\\<br>\end{matrix} \right] \left[ \begin{array}{c}<br>    P\\<br>    1\\<br>\end{array} \right] &#x3D;\left[ \begin{array}{c}<br>    MP+T\\<br>    1\\<br>\end{array} \right]<br>$$</p><p>从式中可以看出，构造特殊的4维矩阵，就可以让计算之后的结果，正好是原来向量与左上角的3维矩阵相乘(MP)，再加上偏移变换T  </p><p>没毛病，但是如果能从几何的角度去解释这个事情，就可以更透彻的理解变换矩阵</p><h3 id="二维情况"><a href="#二维情况" class="headerlink" title="二维情况"></a>二维情况</h3><p>一个二维的点$(x, y)$, 加上第三个维度并赋值1，变为 $(x, y, 1)$, 其几何本质是把原来二维$xoy$平面上的点，看做三维空间中$z&#x3D;1$的平面上的点在$xoy$平面的投影：</p><img src="/2023/07/25/geometry_understanding_of_homogeneous_coordinates/hc1.jpg" class="" title="投影">  <p>如果把二维齐次坐标看作普通的三维向量，那么平移矩阵:<br>$$<br>\left[ \begin{matrix}<br>    1&amp;0&amp;t_x\\<br>    0&amp;1&amp;t_y\\<br>    0&amp;0&amp;1\\<br>\end{matrix} \right]<br>$$<br>其实表示的是三维空间中的一个切变，切变之后的物体投影到二维$xoy$平面，正好就是二维空间中的平移变换:</p><img src="/2023/07/25/geometry_understanding_of_homogeneous_coordinates/sheer.gif" class="" title="切变">  <p>我们知道，矩阵只能用来表示线性变换，而线性变换只有缩放、旋转、切变三种，所以不升维的情况下，同维的矩阵无法表示平移变换<br>通过提升一个维度，把高维的切变投影成低维的平移，就很好的解决了这个问题  </p><p>这也解释了另一个问题，就是$w$元素为什么为1时表示点，为0时表示方向：<br>因为切变操作会固定一个平面 ($z&#x3D;0$平面), 平移另一个平面 ($z&#x3D;1$平面)，如果点在移动的平面上(对应$w&#x3D;1$)，就会被移动，投影也会跟着移动，而点在静止平面上(对应$w&#x3D;0$)，就不会被移动，而方向向量恰好就是不会被移动的，如图：</p><img src="/2023/07/25/geometry_understanding_of_homogeneous_coordinates/dir.gif" class="" title="方向">  <p>此外，如果不升维的话，要表示平移变换，就只能 $MP+T$, 连续两次变换就是 $M_2(M_1P+T_1) + T_2$,三次以上就更麻烦<br>而使用高维齐次矩阵，连续的变换就可以仅用一次矩阵相乘解决，简洁高效</p><h3 id="三维情况"><a href="#三维情况" class="headerlink" title="三维情况"></a>三维情况</h3><p>到了三维，情况其实也是一样的，只不过由原来三维投影到二维，变成了四维投影到三维，而四维平移矩阵表示的也是四维空间中的一个切变</p><p>这里有个难点，就是我们可能不容易想象出四维空间中的切变的几何形状是什么样的，毕竟我们都是三维生物<br>要想清楚这一块其实也不难，首先我们得能在脑中构造出一个四维立方体  </p><p>设第四个坐标轴为$w$轴，直接想比较困难，我们可以先画出$w$轴不垂直于其它三轴的情形，然后再推到垂直的情况，就容易了：<br>先画出平移前后的两个胞体：</p><img src="/2023/07/25/geometry_understanding_of_homogeneous_coordinates/supercube1.jpg" class="" title="supercube1">  <p>再把8个顶点依次连线，就得了一个四维立方体的二维投影：</p><img src="/2023/07/25/geometry_understanding_of_homogeneous_coordinates/supercube2.jpg" class="" title="supercube2">  <p>我画的是不垂直的情况，网上找了张垂直的：</p><img src="/2023/07/25/geometry_understanding_of_homogeneous_coordinates/supercube3.jpg" class="" title="supercube3">  <p>观察这个投影，可以看到一个四维立方体有8个胞体，移动前后本身有两个，六个面各形成一个，加起来8个<br>类比三维中$z&#x3D;1$平面上的切变，四维空间中的切变，其实就是在$w&#x3D;1$的子空间上的切变，切变之后再投影到三维，就变成了平移</p>]]></content>
    
    
    <categories>
      
      <category>Mathematics for Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>投影矩阵的推导过程</title>
    <link href="/2023/07/24/projection_matrix_calculation/"/>
    <url>/2023/07/24/projection_matrix_calculation/</url>
    
    <content type="html"><![CDATA[<p>目标如下图所示，把View Space的坐标映射到Clip Space: </p><img src="/2023/07/24/projection_matrix_calculation/map.png" class="" title="空间映射">                                         <p>这里先做一些前置说明：<br>设View Space (也可以叫做Eye Space)里的点坐标为 $\left( x_e, y_e, z_e, 1 \right) $<br>设Clip Space 里的点坐标为 $\left( x_c, y_c, z_c, w_c \right) $<br>设 NDC Space 里点的坐标为 $\left( x_n, y_n, z_n, 1 \right) $</p><p>同时不考虑viewport非中心对称的情况 (非中心对称时$x_e$和$x_c$并非线性关系)</p><p>以下为推导过程：</p><img src="/2023/07/24/projection_matrix_calculation/proc1.jpg" class="" title="proc1"><img src="/2023/07/24/projection_matrix_calculation/proc2.jpg" class="" title="proc2"><img src="/2023/07/24/projection_matrix_calculation/proc3.jpg" class="" title="proc3"><br/> <br/><p>同时观察$z_e$和$z_n$之前的映射关系:</p><img src="/2023/07/24/projection_matrix_calculation/proc4.jpg" class="" title="proc4"><br/> <br/><p>画个函数图像，绿色和红色$(n,f)$取值分别为 (1, 3), (1, 100):</p><img src="/2023/07/24/projection_matrix_calculation/z_map.jpg" class="" title="z_map"> <p>从图上可以看出：<br>相同$f$值的情况下，$z_e$越接近远平面，其变化引起$z_n$的变化越不明显<br>相同$z_e$值的情况下，$f$越小，变化率(导数)越大<br>这个特性和z-fighting相关，因为$f$较大的情况下，$z_e$的微小变动几乎不会引起$z_n$的变化</p><p>这里想到一点，就是depth buffer里存储的是perspective divide之后的z值，所以early depth test发生在<br>perspective divide之后</p>]]></content>
    
    
    <categories>
      
      <category>Mathematics for Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对法线变换矩阵的理解</title>
    <link href="/2023/07/23/understanding_normal_transform_matrix/"/>
    <url>/2023/07/23/understanding_normal_transform_matrix/</url>
    
    <content type="html"><![CDATA[<p>tangent向量($T$)表示和surface平行的向量，在三角形中可以用两个vertex的差计算，<br>所以T的变换矩阵和vertex的一样，但法线($N$)不同，由于有切变的存在，如果还用相同的矩阵左乘，变换之后的法线将不再和原来的surface垂直:  </p><img src="/2023/07/23/understanding_normal_transform_matrix/error.jpg" class="" title="错误情况"><br/><br/><p>为了确保变换之后的法线依然垂直于surface, 可以从如下条件出发进行推导:<br>$$<br>N\cdot T&#x3D;N^{\prime}\cdot T^{\prime}&#x3D;0<br>$$</p><p>推导过程：  </p><img src="/2023/07/23/understanding_normal_transform_matrix/normal_transform.jpg" class="" title="过程推导"><br/><br/><p>最终有：<br>$$<br>G&#x3D;\left( M^{-1} \right) ^T<br>$$</p><p>即法线的变换矩阵是原矩阵的逆转置(inverse transpose)  </p><p>如果原矩阵是正交矩阵，那么有：<br>$$<br>M^{-1}&#x3D;M^T<br>$$<br>代入上式可得：<br>$$<br>G&#x3D;M<br>$$<br>也就是说如果原来是正交变换，那么法线可以直接用原来的矩阵变换  </p><p>其实几何上是因为，正交矩阵行向量与列向量皆为正交的单位向量，所代表的变换只能是旋转或镜像，有保证原始图形不变形的特性，叫做保距映射，那么因为原来的图形没有变形，法线自然也就不用特殊处理</p>]]></content>
    
    
    <categories>
      
      <category>Mathematics for Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
